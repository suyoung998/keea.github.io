---
layout: post
title:  3D그래픽 프로그래밍 01
category: 3D Graphics Programming 
description: 윈도우 프로그래밍 
---

<h1 id="d-그래픽-프로그래밍">3D 그래픽 프로그래밍</h1>
<h2 id="windows-programming">Windows Programming</h2>
<p><a href="https://www.youtube.com/watch?v=XdtK6f9qVYY&amp;list=PLrrTotxaO6khHInVhLSw3X16VucWW1v1Y&amp;index=2">동영상 강의 : # LinearAlgebra02 Windows Programming</a></p>
<h3 id="win32-소스코드-생성">Win32 소스코드 생성</h3>
<ul>
<li>
<p>파일메뉴 -&gt; 새로만들기 -&gt; 프로젝트<br>
<img alt="생성1" src="https://user-images.githubusercontent.com/26755686/55692848-84fc7b00-59e6-11e9-821f-85f93ca25299.PNG"></p>
</li>
<li>
<p>Visual C++ -&gt; Window 데스크톱 -&gt; Window 데스크톱 응용프로그램 -&gt;이름/위치 정해 주고 -&gt; 확인<br>
<img alt="생성2" src="https://user-images.githubusercontent.com/26755686/55692861-a5c4d080-59e6-11e9-9174-b59ec44f7c6e.PNG"></p>
</li>
<li>
<p>자동으로 필요한 코드 생성됨.</p>
</li>
</ul>
<h3 id="윈도우즈-운영체제-구조">윈도우즈 운영체제 구조</h3>
<h4 id="윈도우-핸들window-handle">윈도우 핸들(Window handle)</h4>
<p><strong>윈도우 핸들</strong> :  운영체제가 유지하는 각 종류의 구조체를 구분하는 유일한 ID.</p>
<p>윈도우에서는 각각의 윈도의 정보를 관리하는  구조체를 생성.<br>
각각의 구조체에서 유일한 ID를 할당.<br>
그것을 <strong>윈도우핸들</strong>이라고 함.</p>
<p>윈도우에 대한 정보를 얻을려면 윈도우 핸들을 알아야 함.</p>
<p><img alt="그림1" src="https://user-images.githubusercontent.com/26755686/55692886-c725bc80-59e6-11e9-886a-c7eb3e04f223.png"></p>
<h4 id="디바이스-컨텍스트dc-device-context">디바이스 컨텍스트(DC, Device Context)</h4>
<p><strong>디바이스 컨텍스트</strong> : 그리기 정보에 대한 구조체</p>
<p>화면에 무언가를 그리고 싶어 할 때 클라이언트 영역에 그려야 함.<br>
이 그리기에 대한 정보를 윈도우가 구조체로 관리함.<br>
이 구조체를 <strong>디바이스 컨텍스트</strong>라고 함.<br>
<img alt="그림2" src="https://user-images.githubusercontent.com/26755686/55692899-df95d700-59e6-11e9-8d9d-08c813d2b698.png"></p>
<h4 id="윈도우에-무언가를-그리기">윈도우에 무언가를 그리기</h4>
<ol>
<li>윈도우의 윈도우 핸들을 얻어야 함.</li>
<li>윈도우 핸들을 전달하면, 디바이스 컨텍스트 구조체의 핸들(HDC)를 얻을 수 있다.</li>
<li>다양한 그리기 정보를 DC에 설정 할 수 있다.</li>
</ol>
<h3 id="그리기-함수의-추가">그리기 함수의 추가</h3>
<p>그리는 함수 추가해보기.<br>
WndProc 함수 위에 추가.<br>
함수 이름 : OnPaint</p>
<pre><code>void OnPaint(HDC hdc)
{
}
</code></pre>
<p>wWinMain() : 윈도우 프로그램 시작 함수.<br>
WndProc : 윈도우에서 메시지가 발생하면 윈도우 프로시저 호출.<br>
WM_PAINT : 윈도우즈 영역을 그려할 때 메시지 발생.</p>
<p>WM_PAINT가 발생할 때 그리기 함수 호출.</p>
<pre><code>case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hWnd, &amp;ps);
        // TODO: 여기에 hdc를 사용하는 그리기 코드를 추가합니다...
		OnPaint(hdc);
        EndPaint(hWnd, &amp;ps);
    }
    break;
</code></pre>
<blockquote>
<p><strong>좌표계</strong><br>
클라이언트 영역은 <strong>스크린 좌표계</strong> 사용.<img alt="그림3" src="https://user-images.githubusercontent.com/26755686/55692910-f63c2e00-59e6-11e9-928f-c188efcae2bb.png">&gt;스크린 좌표계 : 스크린 좌표계의 원점은 좌측 상단이며, x축은 오른쪽 방향으로 증가하는 값을 갖고, y축은 아래 방향으로 증가하는 값을 가짐.</p>
</blockquote>
<pre><code>void OnPaint(HDC hdc)
{
	MoveToEx(hdc, 0, 0, NULL);
	LineTo(hdc, 100, 100);
}
</code></pre>
<p>(0,0)에서 (100,100)에 선이 그려짐.<br>
<img alt="선그리기" src="https://user-images.githubusercontent.com/26755686/55692916-0a802b00-59e7-11e9-804b-bee4729a8e6e.PNG"></p>
<blockquote>
<p><strong>선 그리기</strong><br>
CP(Current Point) : 그래픽에서 보이지 않는 현재 위치, 그래픽 그리기 시점에 현재 점의 위치(x,y)<br>
MoveToEx 함수 : CP를 옮기는 함수<br>
LineTo함수 : 현재 CP에서 특정한 위치까지 선을 그리는 함수</p>
</blockquote>
<h3 id="윈도우즈-프로그래밍">윈도우즈 프로그래밍</h3>
<ol>
<li>
<p>특정한 이벤트가 발생하면 이벤트에 해당하는 메시지를 각 응용 프로그램의 메시지 큐(Message Queue)에 넣음.<br>
<img alt="윈도우즈1" src="https://user-images.githubusercontent.com/26755686/55692929-1c61ce00-59e7-11e9-9d10-1b1d29eec8f0.png"></p>
</li>
<li>
<p>응용 프로그램에서 자신의 메시지 큐에서 메시지를 꺼내오는 루프가 존재.<br>
이것을 <strong>메시지 루프</strong>라고 함.<br>
<img alt="윈도우즈2" src="https://user-images.githubusercontent.com/26755686/55692938-326f8e80-59e7-11e9-9a06-277e80259d48.png"></p>
<ul>
<li>
<p>GetMessage : 메시지를 꺼냄.<br>
WM_QUIT를 빼냈을 때 0을 리턴.<br>
<img alt="윈도우즈3" src="https://user-images.githubusercontent.com/26755686/55692954-43200480-59e7-11e9-8b34-c060eef4c543.png"></p>
</li>
<li>
<p>DispatchMessage() : 윈도우 프로시져 호출<br>
<img alt="윈도우즈4" src="https://user-images.githubusercontent.com/26755686/55692959-4fa45d00-59e7-11e9-9a7f-4cfbbe9b7df0.png"></p>
</li>
</ul>
</li>
<li>
<p>GetMessage()가 가져온 메시지에 대해서 처리를 하기 위해서 윈도우 프로시져(Windows Procedure) 함수 호출.</p>
<ul>
<li>윈도우 프로시져는 내가 호출하는 것이 아니라, 윈도우가 호출하는 것이므로 CALLBACK으로 작성.</li>
<li>DispatchMessage() : 특정 메시지에 대해서 이 함수를 호출해달라고 윈도우 운영체제에게 요청하는 함수.</li>
<li>윈도우 클래스를 등록할 때 윈도우 프로시져를 등록.</li>
</ul>
<p><img alt="윈도우즈5" src="https://user-images.githubusercontent.com/26755686/55692964-5df27900-59e7-11e9-86e0-489676ce1d0b.png"></p>
<p>윈도우 메시지 종류</p>
<ul>
<li>WM_DESTROY :  윈도우가 파괴될 때 호출.</li>
<li>WM_COMMAND : 키보드나 윈도우 메뉴와 관계됨.</li>
<li>WM_PAINT : 어딘가를 갱신해야 할 때 호출.</li>
</ul>
</li>
</ol>
<ul>
<li>
<p>가장 간단한 메시지 루프 구조</p>
<pre><code>  while (GetMessage(&amp;msg, nullptr, 0, 0))
  {
      DispatchMessage(&amp;msg);
  }
</code></pre>
</li>
<li>
<p>그외</p>
<ul>
<li>PeekMessage : 메시지를 꺼내오지 않고 가져옴. 메시지는 메시지 큐에 남아있음.</li>
<li>WM_PAINT 메시지
<ul>
<li>GetMessage()를 호출 했을 때 메시지 큐에서 제거되지 않음.</li>
<li>여러 번 갱신되어야 할 필요가 있을 때, 한번만 갱신하기 위해서.<br>
ex) 화면을 10번 갱신해야 함. 그런데 아직 이전 WM_PAINT메시지가 처리되지 않은 메시지가 있을 수 있음. 만약 모였다가 처리가 된다면 필요없이 똑같은 화면을 여러번 그리는 일이 발생.</li>
<li>WM_PAINT 메시지를 처리할 때는 반드시 WM_PAINT를 메시지 큐에서 지워야 함 -&gt; BeginPaint함수</li>
</ul>
</li>
<li>BeginPaint 함수
<ul>
<li>
<p>메시지 큐에서 WM_PAINT메시지를 제거.</p>
</li>
<li>
<p>BeginPaint함수를 호출하지 않으면, 계속 WM_PAINT 메시지가 발생. OnPaint함수가 계속 호출.</p>
<pre><code>  case WM_PAINT:
  {
      PAINTSTRUCT ps;
      HDC hdc = BeginPaint(hWnd, &amp;ps);
      OnPaint(hdc);
      EndPaint(hWnd, &amp;ps);
  }
  break;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>

