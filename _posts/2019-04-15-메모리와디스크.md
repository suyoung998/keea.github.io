---
layout: post
title:  메모리와 디스크
category: 게임을 움직이는 기술과 발상
description: 메모리와 디스크
---

# 메모리와 디스크
> 게임기는 디스크에 담긴 게임 프로그램과 데이터를 메모리로 읽어와 게임을 실행한다.
디스크와 메모리를 효율적으로 다루는 방법을 생각해보자.

## 메모리란
#### 디스크
장점 : 많은 데이터를 보관 할 수 있음.
단점 : 데이터양이 많아지면 데이터 읽는 속도가 느려지는 단점.
#### 메모리
디스크 단점 보완.
일시적으로 데이터를 저장하는 곳.

![그림1](https://user-images.githubusercontent.com/26755686/56102563-b6d28c00-5f68-11e9-8283-38d4381fc8eb.png)

## 메모리의 단위
메모리는 데이터를 저장하는 데 사용되며, 크기에 제한.
메모리의 단위 : 바이트(Byte)
![그림2](https://user-images.githubusercontent.com/26755686/56102679-7f181400-5f69-11e9-89f1-9d71b22c0703.png)
![그림3](https://user-images.githubusercontent.com/26755686/56102701-9f47d300-5f69-11e9-8fa6-b87a52559a65.png)
1바이트 : 256단계
2바이트 : 256 X 256단계
4바이트 : 256 X 256 X 256 X 256단계
## 1바이트를 세세하게 나눈다.
![그림4](https://user-images.githubusercontent.com/26755686/56102805-53495e00-5f6a-11e9-8ade-8c528437090b.png)
## 메모리의 최대수
1KB(킬로바이트) : 1,024B(바이트)
1MB(메가바이트) : 1,024KB
1GB(기가바이트) : 1,024MB
1TB(테라바이트) : 1,024GB

- 1000 = 2 X 2 X 2 X 5 X 5 X 5
- 1024 = 2 X 2 X 2 X 2 X 2 X 2 X 2 X 2 X 2 X 2
- 1024는 모두 **'2'** 로 표현할 수 있으므로 '1000'이 아닌 '1024'를 사용.

## 어드레스
메모리는 게임 정보를 관리하기 위한 영역이지만 '영역'에는 몇 개의 범위가 있어서 특정 장소를 지정해야 함.
**어드레스** : 메모리 장소를 가리키는 '주소'.
![그림5](https://user-images.githubusercontent.com/26755686/56103247-d4a1f000-5f6c-11e9-920f-fa9c91ae68f4.png)
## 게임에서의 메모리 사용법
메모리의 사용법은 게임 제작에게 대부분 일임.
미리 확보할 분량과 게임 프로그램 자체가 차지하는 분량 이외에는 모두 이용 할 수 있음.
![그림6](https://user-images.githubusercontent.com/26755686/56103449-e1731380-5f6d-11e9-97c3-b36cdf5f8b21.png)
게임을 구성하는 것에는 게임을 실행할 때 표시되는 시작 화면과 그 외 화면에 추가할 타이틀 화면, 메뉴 화면, 엔딩 스텝 롤 등이 있다.

![그림7](https://user-images.githubusercontent.com/26755686/56103814-a671df80-5f6f-11e9-9b30-5fcbe1ac36a9.png)
## 상주와 비상주
화면 단위로 바뀔 때는 메모리 내 데이터를 전부 바꾸지 않아도 되지만, 앞에서 설명한 것처럼 바꾸기 위해서는 데이터를 불러오는 데 어느 정도의 시간이 걸린다.

자주 사용하는 데이터는 전원을 켤 때 불러내어 메모리에 두고, 이후 게임이 종료될 때까지 그대로 유지하는 것이 효율적.

메모리상에 계속 존재하도록 지속하는 상태를 **상주** 라고 함.

![그림8](https://user-images.githubusercontent.com/26755686/56104096-3cf2d080-5f71-11e9-982f-15c820f84e71.png)

## 확보와 해제
화면마다 데이터를 어떻게 배치할 것인가?

![그림9](https://user-images.githubusercontent.com/26755686/56104357-4892c700-5f72-11e9-81d8-361a786a204b.png)

이러한 것을 메모리에 배치해야 하는데, 이때 '확보'와 '해제'작업이 필요하다.

![그림10](https://user-images.githubusercontent.com/26755686/56106176-d70b4680-5f7a-11e9-9f48-0fe7859ba07b.png)
**확보** : 데이터 크기를 지정해 사용을 명시하는 것.

메모리를 '확보'하면 메모리의 어느 곳에 데이터를 배치하면 좋을지에 대한 정보, 어드레스를 받음.
어느 장소의 어드레스를 받을지는 처리에 따라 매번 달라짐, 메모리 내에 비어 있는 적잘한 장소의 어드레스를 받게 됨.

![그림11](https://user-images.githubusercontent.com/26755686/56106409-efc82c00-5f7b-11e9-8fb1-df230b8216a7.png)

메모리 내의 데이터가 불필요한 경우에는 폐기해야 함. 폐기하지 않으면 다른 처리에서 메모리를 필요로 할 때 그 영역을 차지하고 있어 사용할 수 없기 때문.

**헤재** : 메모리 내의 데이터를 폐기하는 것.

'확보'했을 때 얻은 어드레스에 '해제'할 시점을 미리 지정해두면 확보 영역은 다시 사용할 수 있는 상태가 됨.

![그림12](https://user-images.githubusercontent.com/26755686/56106535-9ad8e580-5f7c-11e9-87b9-5a2195332875.png)

게임 프로그램 내부에서는 이와 같이 메모리의 확보와 해제가 반복되고 있음.

## 메모리를 확보할 수 없는 요인

게임을 만들 때는 각 화면의 데이터 크기를 고려해 메모리에 적재할 수 있도록 설계.
그러나 어떤 요인으로 인해 메모리를 확보할 수 없게 되는 경우가 있는데, 그 주요 요인이 바로 '연속된 영역을 확보할 수 없다.'라는 점.

메모리를 확보해 데이터를 배치할 때는 데이터의 순서가 상당히 중요.

![그림13](https://user-images.githubusercontent.com/26755686/56106748-9660fc80-5f7d-11e9-8ff1-cd442ddf9c86.png)

![그림14](https://user-images.githubusercontent.com/26755686/56106904-59493a00-5f7e-11e9-8178-4e002b860b78.png)

![그림15](https://user-images.githubusercontent.com/26755686/56106984-bd6bfe00-5f7e-11e9-9ad7-7d79195ded4a.png)

빈 공간의 총합계만 고려한다면 메뉴 화면 그래픽 데이터를 배치할 수 있지만, 배치 방법에 따라서는 공간 확보가 불가능 할 수도 있음.

메모리의 이러한 상태를 **단편화** 혹은 **파편화** 라고 부르며, 메모리의 확보, 해제의 관점에서 보면 단편화되어 있는 상태는 상당히 비효율적이라고 볼 수 있음.

![그림16](https://user-images.githubusercontent.com/26755686/56107172-c5786d80-5f7f-11e9-918d-73593667b2b2.png)

## 단편화를 피하기 위한 방법
데이터를 불러오는 순서와 배치 위치를 정확히 관리하면 메모리의 단편화를 피할 수 있을 것이라고 생각할 수 있지만, 실제로는 조금 더 복잡한 과정을 거쳐야 함.

어느 정도 단편화에 대한 대책을 마련해둬야 함.
### - 카테고리마다 영역을 나눈다.
메모리의 영역을 각 카테고리마다 미리 나누어 둔다.

![그림17](https://user-images.githubusercontent.com/26755686/56107777-29506580-5f83-11e9-962f-2fd038f37053.png)

이와 같이 미리 영역을 나누어두면 다른 영역을 침범하는 일 없이 적절하게 확보와 해제를 실행 할 수 있다.
### - 소용량과 대용량으로 나눈다.
큰 데이터와 작은 데이터의 혼재를 피함으로써 단편화를 방지.

![그림18](https://user-images.githubusercontent.com/26755686/56108148-29516500-5f85-11e9-98a6-0d917820047f.png)

### - 일정 기간으로 재배치한다.
**컴팩션** : 단편화가 발생한 상태에서 사용 중인 영역만을 모아 정리함으로써 비어 있는 용량을 확보하는 방법.

![그림19](https://user-images.githubusercontent.com/26755686/56108314-3d499680-5f86-11e9-81ec-36a9e22d8bfa.png)

빈 공간이 늘어나 큰 데이터를 배치해도 문제가 없을 것임.

배치를 조정한다는 것은 데이터의 어드레스가 바뀌는 것을 의미하기 때문에, 프로그램 측면에서도 이러한 점을 고려해 데이터의 어드레스 또한 바꿔야 함.

![그림20](https://user-images.githubusercontent.com/26755686/56108573-8b12ce80-5f87-11e9-8551-a26c3387e080.png)

어드레스를 변경해야 하는 처리와 데이터를 정리해 옮기는 과정에도 시간이 소요.

### - 단편화 대책 총정리
세 가지 단편화 대책을 소개.

어떤 방법이든지 단편화를 완전히 해소 할 수 있는 방법이 아니라 단편화의 가능성을 최대한 낮추는 것에 불과.

결론적으로 게임이 문제없이 동작하면 좋겠지만, 그러기 위해서는 프로그래머가 메모리의 상태를 항상 고려하면서 프로그램을 구성하는 것이 가장 좋은 해결방법일 것임.

## 메모리릭
'메모리릭' 혹은 '메모리 누수' : 불필요한 데이터를 남겨둔 채로 처리를 진행하는 것.

![그림21](https://user-images.githubusercontent.com/26755686/56108921-4d16aa00-5f89-11e9-80a3-85a620134954.png)

플레이 데모에서 타이틀 화면으로 돌아올 때마다 플레이어 데이터가 겹치게 됨.

머지 않아 타이틀 화면에서 필요한 데이터를 확보할 수 없게 되고 그에 따라 게임이 정지됨.

## 디스크에서 불러오기

디스크에서 불러오는 시간은 기본적으로 데이터 크기에 비례.

![그림22](https://user-images.githubusercontent.com/26755686/56109784-03c85980-5f8d-11e9-8d62-23e68b1fcc8d.png)

## 탐색이란
판형의 디스크를 읽기 위해서는 드라이브에 있는 헤드라는 읽기 장치를 판 위에 이동시켜 필요한 크기만큼의 데이터를 불러옴.

**탐색** : 데이터를 읽기 위해 실행하는 헤드의 이동.

![그림23](https://user-images.githubusercontent.com/26755686/56110039-f6f83580-5f8d-11e9-9720-a42472fd5016.png)

이러한 탐색에 걸리는 시간도 실제로 게임에서 체감하는 불러오기 시간에 포함.
탐색 시간을 얼마나 빠르게 할지가 불러오기 시간 전체를 단축시키는 것에 직결됨.

## 데이터 정리 및 배치

탐색 시간을 단축시키기 위한 첫 번째 방법 : 각 장면에 필요한 데이터를 디스크 상에 제각각 배치하지 않는다.

앞의 데이터를 디스크의 안쪽부터 순서대로 불러오는 것을 생각해보자.

![그림24](https://user-images.githubusercontent.com/26755686/56110687-58210880-5f90-11e9-8287-4be451fbfb31.png)

안쪽부터 순서대로가 아닌 제각각의 순서로 불러오게 되면 어떻게 될까요?

![그림25](https://user-images.githubusercontent.com/26755686/56110748-90c0e200-5f90-11e9-83f6-e552f6e65a58.png)

데이터가 제각각 배치되어 있는 경우 헤드의 이동량이 많아지게 됨.
게임 장면에 따라 데이터를 불러오는 상황을 고려해 디스크에 데이터를 정리해서 배치해야 함.

## 필요한 데이터를 중복시킨다.

스테이지 1과 스테이지 2에서 같은 적이 등장할 수도 있음. 이러한 경우 스테이지 1의 데이터가 디스크상에 정리되어 있다면 스테이지 2에서는 적의 일부를 스테이지 1의 영역에서 불러올 수 있음.

그렇게 하면 탐색시간이 늘어남.

![그림26](https://user-images.githubusercontent.com/26755686/56111312-78ea5d80-5f92-11e9-9e37-9af1224204a2.png)

최근 게임에서 사용되는 디스크는 대용량을 사용하는 경우가 많음.
대용량의 장점을 살려 일부러 같은 데이터를 여러 곳에 배치하는 것도 효과적일 수 있음.

![그림27](https://user-images.githubusercontent.com/26755686/56111739-f498da00-5f93-11e9-8d4f-69dca11856c5.png)

디스크의 용량은 할애되지만 탐색에 소요되는 시간을 줄여주어 불러오기 시간을 단축시킬 수 있음.

## 데이터를 하나의 파일로 정리
여러 개가 서로 가까운 위치에 있게 정리함으로써 불러오기 시간을 단축할 수 있지만, 탐색 시간은 존재.
데이터를 읽기 위한 사전 준비와 사후 준비에도 처리시간이 다소 걸림.

장면마다 데이터를 중복 데이터로 배치하지 않고 하나의 데이터로 정리하는 것.
하나의 데이터로 정리하면 탐색 시간은 없어지고 사전 사후 준비는 1회로 끝나게 되어 시간이 단축.

![그림28](https://user-images.githubusercontent.com/26755686/56112240-64f42b00-5f95-11e9-87a9-a63a5c940314.png)

디스크에서 불러온 데이터를 메모리에 배치할 때는 데이터를 세세히 나눌 수가 없기 때문에 메모리에 큰 공간이 필요하게 되는 단점.

![그림29](https://user-images.githubusercontent.com/26755686/56112363-d633de00-5f95-11e9-8c86-1db05518003d.png)
## 데이터 압축

데이터가 하나여도 데이터 크기가 크면 그만큼 불러오는 시간이 오래 걸릴 것임.

그래서 데이터를 압축해 크기를 작게 해둠. 크기가 작아지면 불러오는 시간이 짧아지기 때문에 압축은 상당히 효과적.

![그림30](https://user-images.githubusercontent.com/26755686/56112628-9a4d4880-5f96-11e9-934f-61416ae7cf34.png)

압축 함으로써 디스크의 용량도 효율적으로 사용할 수 있기 때문에 보다 많은 데이터를 담을 수 있음.

![그림31](https://user-images.githubusercontent.com/26755686/56112754-f7e19500-5f96-11e9-96d4-9b018af768e4.png)

## 압축 데이터 복원

압축한 데이터는 그대로 사용할 수 없음. 압축하기 전 상태로 되돌아가는 작업을 **압축해제** 또는 **압축풀기** 라고 함.

복원에는 별도의 메모리 공간 홥보가 필요. 대부분의 경우 압축 전 원래의 데이터 크기와 동일한 크기의 메모리 공간을 확보해야 함.

![그림32](https://user-images.githubusercontent.com/26755686/56113106-d6cd7400-5f97-11e9-82b8-bbcae136b41d.png)

## 장면 전환 작업
게임에 필요한 데이터를 게임 서두에서 모두 메모리에 넣어두면 불러오기가 필요하게 됨.

그러나 그렇게 되면 메모리 크기 문제로 각각의 데이터의 질이 낮아지고 사용자가 만족할 수 없는 상태가 될 것임.

때론 이러한 생각들을 부분적으로 도입하는 것이 상당히 효과적일 때가 있음.

예를 들어 대부분의 액션게임은 스테이지를 세세한 영역으로 나누어 영역 단위로 게임을 진행. 플레이어나 적, HP 표시 등의 데이터는 그대로 유지하고, 배경 데이터만 변경해야 할 경우가 생김.

![그림33](https://user-images.githubusercontent.com/26755686/56113855-172df180-5f9a-11e9-85be-811102589845.png)

장면(scene) 전환 작업 :  영역 1을 한참 플레이하고 있는 도중에 영역 2의 배경 데이터를 미리 불러 두는 것.

장면 전환 작업을 실행하기 위해서는 메모리의 사용 방법에 주의할 필요가 있음.

배경 데이터가 들어갈 영역을 두 개 준비해두고, 먼저 한 개에 현재 데이터를 넣어 사용하고 다른 한 개에는 다음 영역의 배경 데이터를 미리 불러두는 것.

![그림34](https://user-images.githubusercontent.com/26755686/56114287-6294cf80-5f9b-11e9-9d6d-441421bdec3d.png)

![그림35](https://user-images.githubusercontent.com/26755686/56114400-b4d5f080-5f9b-11e9-90d8-bbd95b7acfb6.png)

![그림36](https://user-images.githubusercontent.com/26755686/56114509-ff576d00-5f9b-11e9-8ca3-268bf6b32848.png)

단점 : 배경 데이터 두 개 분량의 메모리 공간을 확보하기 때문에, 그만큼 데이터의 질이 낮아질 수도 있음.
데이터의 질과 메모리의 사용량과 밸런스를 고려하기 위해서는 실제로 데이터를 작성하는 디자이너의 협력이 필요.

난제 : 사용자가 영역 1을 상당히 빠른 속도로 종료했을 때도 여전히 대기시간이 생긴다는 점.
하지만 이러한 문제는 게임 밸런스 조정으로 충분히 해소할 수 있는 문제.
