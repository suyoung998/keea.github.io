---
layout: post
title:  수치표현과 연산
category: 게임을 움직이는 기술과 발상
description: 우리는 숫자를 '1'부터 세는 데 익숙하지만, 프로그래밍에서는 약간의 '사고의 전환'이 요구됩니다. 컴퓨터의 특성과 제약을 고려한 수치 표현법을 살펴보자.
---

> 우리는 숫자를 '1'부터 세는 데 익숙하지만, 프로그래밍에서는 약간의 '사고의 전환'이 요구됩니다. 컴퓨터의 특성과 제약을 고려한 수치 표현법을 살펴보자.



# 10진수와 2진수

**10진법** : 한 자릿수가 0에서 9까지의 10단계가 있고 그 이상이 되면 자릿수가 늘어나는 숫자 세기 방법.

**10진수** : 10진법으로 표현할 수 있는 수.



## 2진수

1비트는 '0'이나 '1'처럼 두 단계를 표현할 수 있다.

0과 1의 두 종류 숫자만으로 표현할 수 있는 2진수가 컴퓨터에 적합하다.

| 10 진수 |    1 |    2 |    3 |    4 |    5 |    6 |
| :-----: | ---: | ---: | ---: | ---: | ---: | ---: |
| 2 진수  |    0 |    1 |   10 |   11 |  100 |  101 |

2진수의 자릿수 증가 : 10진수의 1에서 2가 될 때 2진수에서는 자릿수 증가가 발생하여 '1'에서 '10'이 됨.



### 1바이트가 255가 되는 이유 

255는 2진수의 '11111111'로 1이 8개가 나열된 수를 표현.

다음 수인 256은 '100000000'이 되어 자릿수 증가가 발생해 '0'이 8개가 되기 때문에, 255는 8자릿수로 이루어진 2진수의 최대수가 됨. 

즉, 1바이트는 8자릿수의 2진수와 같은 것.

| 10진수 |     2진수 |
| -----: | --------: |
|      0 |         0 |
|      1 |         1 |
|      2 |        10 |
|      3 |        11 |
|    ... |       ... |
|    253 |  11111101 |
|    254 |  11111110 |
|    255 |  11111111 |
|    256 | 100000000 |
|    257 | 100000001 |



# 16진수

0과 1이 여러 개가 나열되는 2진수의 표현은 자릿수가 길기 때문에 장황해 보일 수 있음.

그래서 등장하는 것이 16진수.

16진수는 16종류의 문자가 필요하며, 다음과 같이 숫자를 셈.

> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F

숫자에 'A~F'의 알파벳을 사용해 표현.

| 16진수 | 0    | 1    | 2    | ...  | 8    | 9    | A    | B    | C    | D    | E    | F    | 10   | 11   |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 10진수 | 0    | 1    | 2    | ...  | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   |

A가 10진수의 10, B가 10진수의 11에 해당.

16진수에도 자릿수 증가 발생하고 F 다음은 10이 됨.

16진수의 '10'은 10진수의 16에 해당.

| 16진수 |    0 |    1 |    2 |    3 |    4 |    5 |    6 |    7 |    8 |
| ------ | ---: | ---: | ---: | ---: | ---: | ---: | ---: | ---: | ---: |
| 2진수  |    0 |    1 |   10 |   11 |  100 |  101 |  110 |  111 | 1000 |

| 16진수 |    9 |    A |    B |    C |    D |    E |    F |        10 |
| ------ | ---: | ---: | ---: | ---: | ---: | ---: | ---: | --------: |
| 2진수  | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 | 0001 0000 |

16진수의 1자릿수는 2진수의 4자릿수에 상응.

ex) 16진수 0 ~ F는 2진수 '0000' ~ '1111'이 됨.

| 10진수 | 2진수     | 16진수 |
| ------ | --------- | ------ |
| 253    | 11111101  | FD     |
| 254    | 11111110  | FE     |
| 255    | 11111111  | FF     |
| 256    | 100000000 | 100    |
| 257    | 100000001 | 101    |

1바이트는 두 자리의 16진수, 즉 0~FF 표현할 수 있음.

2바이트의 경우 0 ~ FFFF. 4바이트의 경우 0 ~ FFFFFFFF

16진수를 나타낼 때는 서두에 '0x'를 붙임. 

> 0xFF



# 덧셈, 뺄셈, 정수, 음수

## 덧셈, 뺄셈

10진수와 마찬가지로, 16진수에도 덧셈이나 뺄셈이 있다.

> 0x0A + 0x0F = 0x19

0x0A(10)와 0x0F(15)의 합은 0x19(25)가 됨. 괄호 안의 숫자는 10진수이며, 이와 같이 10진수로 환산하면 어느 정도 계산이 쉬워진다.

16진수 계산은 숙련된 프로그래머라도 바로 대답하는 것은 불가능할 것이다. 주로 전자 계산기로 계산하는 경우가 대부분이기 때문에 바로 대답할 수 없다고 해서 슬퍼할 필요는 없다.

## 정수, 음수

1바이트는 0부터 255까지라면 '정수로 밖에 표현할 수 없는 것인가?'

음수도 표현할 수 있다. 그러기 위해서는 2의 보수(2's complement)라는 표현방법을 이용해야 한다.

ex) 0x48(10진수의 72)

- 우선 2진수로 나타낸다.
- 01001000
- 이 숫자에서 0은 1로, 1은 0으로 변환한다.
- 01001000 -> 10110111
- 마지막으로 이 수에 1을 더한다.
- 1011 0111 + 1 = 1011 1000 = 0xB8

이와 같은 방법으로 0xB8이 완성. 이것은 0x48(72)의 마이너스 값, 즉 -0x48(-72)에 해당.

실제로 음수인지 확인. 음수라면 0x48과 0xB8의 합은 0x00이 될 것임.

  0x48 = 0100 1000

+0xB8 = 1011 1000

​             10000 0000 = 0x100

계산 결과 0x100이 되었다. 1바이트로 계산하면 3번째 자릿수는 1바이트로 표현할 수 있는 범위를 초과하기 때문에 무시. 따라서 0x48의 음수는 0xB8이라는 것을 알 수 있음.



2진수로 나타낸 경우 최상위(왼쪽 끝) 숫자가 '1'이면 음수가 됨. 게임에서는 이 부분만 체크해 마이너스 여부를 판단 할 수 있음.

| 10진수 |     2진수 | 16진수 |
| -----: | --------: | -----: |
|    127 | 0111 1111 |   0x7F |
|    126 | 0111 1110 |   0x7E |
|    125 | 0111 1101 |   0x7D |
|    ... |       ... |    ... |
|      2 | 0000 0010 |   0x02 |
|      1 | 0000 0001 |   0x01 |
|      0 | 0000 0000 |   0x00 |
|     -1 | 1111 1111 |   0xFF |
|     -2 | 1111 1110 |   0xFE |
|    ... |       ... |    ... |
|   -126 | 1000 0010 |   0x82 |
|   -127 | 1000 0001 |   0x81 |
|   -128 | 1000 0000 |   0x80 |

'1바이트는 0에서 255'라고 설명했던 것처럼 '1바이트는 -128에서 127'이라고 생각할 수 있음.

1바이트를 어떻게 취급할지는 프로그램에서 조정할 수 있기 때문에, 상황에 따라서는 다르게 사용할 수도 있음.



## 비트시프트

예전의 CPU는 덧셈이나 뺄셈 연산에는 효율적인 반면에 곱셈이나 나눗셈 연산을 처리하기에는 적합하지 못함. 왜냐하면 CPU가 곱셈이나 나눗셈의 기능을 갖추고 있지 않았기 때문. 그래도 계산이 가능했던 것은 비트를 정교하게 조작함으로써 곱셈이나 나눗셈과 같은 결과를 얻을 수 있었기 때문.

**비트시프트** : 수치를 2진수로 표현하고 그 수치표현 전체를 오른쪽에서 왼쪽으로 이동(시프트)시키는 것을 말함.

![그림1](https://user-images.githubusercontent.com/26755686/57839583-f6a7c000-7801-11e9-8528-aac34dcb7cc3.png)



ex) 0x2C(44)라는 수를 이동(시프트)하는 경우.

- 왼쪽으로 1비트 이동(시프트).
  - 왼쪽으로 이동(시프트)하고 왼쪽의 남는 부분은 버림.
  - 이동(시프트)함에 따라 오른쪽에 발생하는 비어 있는 흰 부분에는 0을 채워 넣음.
  - 그 결과 0x58이 되고, 이것은 10진수의 88임.
  - 원래 수가 0x2C(44)이기 때문에 2배 값이 됨.
  - 왼쪽으로 한 칸 이동(시프트)함으로써 원래 수의 2배가 되는 효과를 얻을 수 있음.
- 오른쪽으로 1비트 이동(시프트).
  - 오른쪽 남는 부분을 버리고 왼쪽에 발생하는 비어 있는 흰 부분에는 0을 채워 넣음.
  - 0x2C(44)를 오른쪽으로 한 칸 이동(시프트)한 결과는 0x16입니다.
  - 10진수의 22이므로 원래 수의 1/2이 됨.

![그림2](https://user-images.githubusercontent.com/26755686/57913160-f7eef080-78c6-11e9-9615-bbbc0f492c65.png)

비트를 이동(시프트)함으로써 제한적이긴 하지만 2배 또는 1/2배의 단위로 곱셈이나 나눗셈을 표현할 수 있음.

비트시프트 계산은 상당히 빠르게 실행할 수 있어서 지금까지도 사용되는 경우가 있음.

비트시프트 수식 표현

> 0x80 >> 1 = 0x40

'>>'은 오른쪽으로 이동(시프트)을 나타냄. '>>'의 우측 숫자는 이동(시프트)할 수치임.

> 0x10 << 2 = 0x40

'<<'은 왼쪽으로 이동(시프트)을 나타냄.  '<<'의 우측 숫자는 이동(시프트)할 수치임.

