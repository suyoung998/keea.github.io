---
layout: post
title:  CPU와 GPU
category: 게임을 움직이는 기술과 발상
description: 게임 프로그램과 그래픽 데이터는 스스로 움직일 순 없다. 바로 CPU와 GPU가 지시를 내려줘야 한다. CPU와 GPU가 어떻게 작동하는지에 대해 알아본다.
---

>  게임 프로그램과 그래픽 데이터는 스스로 움직일 순 없다. 바로 CPU와 GPU가 지시를 내려줘야 한다. CPU와 GPU가 어떻게 작동하는지에 대해 알아본다.



# CPU란

메모리 : 게임에 관련된 데이터를 배치하는 장소.

CPU : 그 데이터를 어떻게 다룰 것인지를 담당. -> 제어기 등 다른 기기를 제어하는 일을 담당하는 등 게임기의 핵심 역할을 함.

게임기는 CPU를 중심으로 동작하는데, CPU는 인간의 뇌와 같은 동작을 담당한다고 볼 수 있다.



# 프로그램과 CPU

CPU를 흔히 뇌와 비교하지만 스스로 동작하지는 않음. 동작하기 위해서는 지시를 받아야 함.

그 지시를 담당하는 것이 바로 프로그램.

프로그램은 게임이 실행될 때 메모리에 배치. CPU는 메모리상의 프로그램 위치를 확인하고 프로그램의 내용을 참조하면서 프로그램의 지시에 따라 동작.

이후 CPU는 프로그램의 내용을 지속적으로 참조하며, 기본적으로 게임이  종료될 때까지 동작함.



# 메모리상의 프로그램

**루프** : 게임에 관련된 처리를 순서대로 불러와 처리가 종료되면 처음부터 다시 처리하는 것을 반복 하는 것.

**메인루프** : 메인이 되는 처리.

메인 루프를 중심으로 각각의 처리를 불러오는 것이 게임의 기본적인 구조가 됨.

ex) 메인 루프에서 '플레이어 관련 처리'를 불러와 그 처리에서 '플레이어의 이동', '플레이어의 공격'이라는 처리를 불러냄.

![그림1](https://user-images.githubusercontent.com/26755686/56466249-15f13e80-644a-11e9-88bf-213573dcebb5.png)



적의 경우에는 플레이어와는 달리 여럿이기 때문에 '적에 관한 처리'를 불러낸 후 스테이지 존재하는 적의 수만큼 반복해 처리.

![그림2](https://user-images.githubusercontent.com/26755686/56466292-b5163600-644a-11e9-9946-c25a7754499f.png)



루프에서 처리를 불러오는 것이 기본이지만, 다음 그림과 같이 직접적인 구조로 구성할 수 있음.

![그림3](https://user-images.githubusercontent.com/26755686/56466345-6fa63880-644b-11e9-89dd-55eab696314e.png)



여러 명에서 프로그램을 개발하는 경우 : 불러오기 처리 장소를 개별적으로 만든 뒤 불러오는 것이 더욱 간단.

혼자서 프로그램을 제작하는 경우하는 경우라도 불러오는 처리 장소를 세세히 만들어두면 다른 부분에서도 유용하게 사용할 수 있어 편리할 것임. 메모리의 사용량도 낮출 수 있고, 오류가 생겼을 때도 문제점을 파악하기 쉬워짐.

개별 처리를 불러오는 형태로 구성하는 것이 전체적으로 효율이 높음.

ex) 플레이어와 적은 지면을 따라 이동하고 대면한 경우에는 서로 상대를 향해 공격할 것임. 공격할 때 그 공격이 상대에게 닿았는지 아닌지를 판단해야 함. 이러한 판단을 **충돌 확인**(또는 **충돌 판정**)이라고 함. 충돌 확인 처리를 플레이어용, 적 전용으로 개별적으로 만들 필요가 없음. 한 개만 만든 다음 플레이어 처리와 적 처리 양쪽 모두 불러오면 되기 때문.

![그림4](https://user-images.githubusercontent.com/26755686/56466419-fdceee80-644c-11e9-98f0-43c47bad5993.png)



# 오버레이

메모리는 한정된 자원이기 때문에, 프로그램을 만들 때 메모리가 부족하면 그래픽 데이터뿐만 아니라 프로그램 자체도 삭제 대상이 됨. 이번에 소개할 내용은 오버레이 방법으로 프로그램을 삭제 처리이다.

게임에는 타이틀 화면과 엔딩 화면이 있음. 우선 게임에서 두 화면이 동시에 실행되는 상황은 없을 것임. 그렇다고 이 두가지 화면의 프로그램으 메모리에 배치하는 것은 낭비라고 볼 수 있음.

![그림5](https://user-images.githubusercontent.com/26755686/56466541-93b74900-644e-11e9-99fa-e78392d8fbc4.png)

타이틀 화면이 표시돼야 될 때는 타이틀 화면 처리를 실행하는 프로그램을 디스크에 불러와 메모리에 배치함. 게임이 진행되고 엔딩이 표시돼야 될 떄는 타이틀 화면 프로그램이 들어 있던 공간에 엔딩 처리를 실행하는 프로그램을 덮어씌움.



타이틀 화면과 엔딩 화면 모두 이러한 처리 덕분에 사용되는 메모리 영역을 조금이라도 비울 수 있음.

![그림6](https://user-images.githubusercontent.com/26755686/56466676-bc8c0e00-644f-11e9-885f-60768f42d134.png)

주의 할 점 

- 그래픽 데이터 등에 비해 프로그램 크기가 작아서 많은 양의 메모리가 절약되는 것은 아니다.
- 오버레이를 실행하면 디버깅을 하기 어려워지거나 오류의 원인도 되기도 하다.

![그림7](https://user-images.githubusercontent.com/26755686/56466731-771c1080-6450-11e9-9a55-93da2ee7016e.png)

> 필요한 프로그램이 메모리 내 존재하지 않는 상황에 빠지는 경우.

오버레이는 특별한 경우를 제외하고는 잘 사용하지 않음.



# 메인 루프의 시작과 끝

메인 루프에서 가장 먼저 하고 싶은 처리 : 제어기로부터 들어온 입력을 확인하는데, 이는 입력 정보에 따라 처리 순서가 크게 달라질 가능성이 높다.

- 제어기 처리를 메인 루프의 도중에 진행

  ![그림8](https://user-images.githubusercontent.com/26755686/56466813-b72fc300-6451-11e9-8857-2bfce16baa78.png)

- 제어기 처리를 메인 루프의 초반에 진행

  ![그림9](https://user-images.githubusercontent.com/26755686/56466843-1beb1d80-6452-11e9-84f8-6e11e110a720.png)

이후의 플레이어나 적의 처리에 걸리는 시간은 상황에 따라 달라질 것임.

ex) 적이 10개 존재할 경우 1개일 때보다 처리시간이 다소 증가한다는 것은 쉽게 예상 가능.

따라서 제어기 처리 시점에 따라 처리 과정의 순서가 달라진다는 것을 알 수 있음.

![그림10](https://user-images.githubusercontent.com/26755686/56466941-8b154180-6453-11e9-8419-4fcc7782e5d9.png)

제어기 정보를 받는 타이밍이 다르면 사용자의 조작감이 떨어져 재미있는 게임이 될 수 없고, 화면상의 플레이어나 적의 이동량도 매번 달라질 뿐만 아니라 시간을 표시하는 카운트다운도 규칙적이지 않게 될 것임.

ex) 플레이어 처리에서 플레이어가 오른쪽으로 50 움직였다고 생각. 매번 같은 움직임을 한다면 동일한 속도로 오른쪽으로 움직일 것이라고 예상하겠지만, 실제로 그림과 같이 처리.

![그림11](https://user-images.githubusercontent.com/26755686/56467084-07f4eb00-6455-11e9-90c1-49ae5b2790b0.png)

플레이어의 위치를 불러오는 타이밍은 일정치가 않음. 그렇기 때문에 같은 속도로 움직이려고 의도하더라도 화면에 표시되는 플레이어는 각기 다른 움직임으로 이동.

이러한 문제는 메인 루프의 마지막에 '일정시간 대기'에 따라 해결 할 수 있다. 1/60초 주기로 특정 신호를 발생시켜 신호를 기다리는 것임.

'일정시간 대기'라는 것은 정확히 '특정 신호 대기'라고 볼 수 있음.

 ![그림12](https://user-images.githubusercontent.com/26755686/56467186-a0d83600-6456-11e9-859a-e416b0706867.png)

이러한 처리를 통해 대기시간은 발생되지만, 제어기 입력을 일정한 간격으로 할 수 있을 뿐만 아니라 플레이어도 같은 속도로 움직이게 할 수 있음.



# 수직동기와 프레임

**수직동기** : '특정 신호 대기'에서 말하는 신호. 기본적으로 1/60초의 주기로 디스플레이에서 발생.

디스플레이어에 어떤 영상이 표시될 때는 화면 위쪽부터 서서히 표시가 바뀜. 이렇게 바뀌는 라인의 화면 가장 아래에 도다하는 타이밍이 수직동기의 시작점이 됨. 바로 이 시점이 메인 루프의 시작으로 가장 좋은 타이밍이라고 할 수 있음.

![그림13](https://user-images.githubusercontent.com/26755686/56467608-1266b300-645c-11e9-8e6d-9e8d387e8ca9.png)

1은 수직 동기가 시작되는 시점임. '1/60초'란 일단 3에 도달하고 다시 1에 도달하기까지의 시간.

이러한 1의 순간에는 디스플레이 화면 가장 아래가 바뀌고 있음. 화면 색이 전부 바뀌면 다시 바뀌는 위치를 가장 위쪽으로 옮기지만, 실제로는 화면 가장 아래의 조금 더 아랫부분까지 바꾸러고 함. 위 그림의 2부분까지 화면을 바꾸는 처리를 지속함. 1에서 2의 구간을 **수직동기 구간**이라고 하며, 게임 화면을 선명하게 바꾸기 위한 상당히 중요한 과정임.

이와 같이 수직동기에 기초한 1/60초라는 시간을 기본단위로 게임 처리 루프를 반복하는데, 이러한 기본 단위를 **프레임**이라고 함. 

앞의 그림에서는 1프레임의 처리를 1/60초 이내에 전부 종료시키고 신호를 기다리고 있지만, 만일 처리가 1/60초를 넘으면 어떻게 될까요?

![그림14](https://user-images.githubusercontent.com/26755686/56467678-12b37e00-645d-11e9-857c-c500f70df02b.png)

프레임이 1/60초를 초과하면 다음 수직동기를 기다리게 됨. 그렇기 때문에 그 프레임에서만 1/30초를 소비하게 됨. 원래 1/60초를 의도하고 작업하던 처리에 두 배의 시간이 걸리게 됨. 이러한 지연이 연속되면 체감할 수 있을 정도로 게임이 느려짐.

![그림15](https://user-images.githubusercontent.com/26755686/56467865-5effbd80-645f-11e9-9b16-7a15befabf94.png)

게임 처리마다 플레이어가 10의 거리만큼 이동하는 예를 그림으로 나타내보면, 수직동기까지 게임 처리가 끝난 경우에는 최종적으로 40의 거리를 이동할 수 있음. 그러나 수직동기를 초과한 경우에는 총 이동량이 20에 그침. 플레이어가 소비하는 시간은 같지만 이동량은 반정도밖에 되지 않기 때문에 플레이어는 느린 게임이라고 느끼게 될 것임.

이와 같은 상태를 **처리지연** 혹은 **딜레이**이라고 함. 액션 게임이나 슈팅 게임 등에서 적이나 무기가 화면에 많이 나타날 경우 표시가 늦어지는 것처럼 느껴질 때가 있는데, 이것이 바로 처리 지연임. 처리지연이 지속되면 게임의 품질이 현저히 떨어지게 됨.



# 30fps 선택

1/60초 : 게임을 작동시키면 캐릭터의 움직임이 매우 매끄럽게 느껴짐.

세세한 움직임x, 좀 더 많은 적 등장 -> 적이나 무기를 많이 표시하면 처리지연이 발생할 가능성이 높음. -> 게임의 즐거움을 잃게 될 것임. 

따라서 1프레임의 해당 시간을 길게 해 2회에 한 번씩 대기하도록 함.

![그림1](https://user-images.githubusercontent.com/26755686/56478149-f3adfe00-64e7-11e9-8296-7b3432e8d872.png)

1프레임의 처리시간이 길어지므로 처리지연의 가능성은 낮아짐. 1/30초이므로 꽤 여유 있게 처리를 실행할 수 있음.

### 단점

- 상세한 움직임은 줄어 들 것임.
- 움직임의 매끄러움을 잃게 됨.

프로그래머는 1프레임의 시간을 짧게 해 매끄럽게 표현할지, 시간을 길게 해 처리량을 늘릴지 양자택일 해야 함. 게임의 특성을 고려해 미리 계획을 세울 필요가 있음.

![image](https://user-images.githubusercontent.com/26755686/56478455-7c2d9e00-64ea-11e9-91b2-8b0cafb17830.png)

### FPS

- '프레임 정보'를 표시하는 단위.
- 'frames per second'의 약자. '1초당 프레임 수'라는 의미.
- 60fps : 1/60초로 반복할 때 1초당 60프레임.
- 30fps : 1/30초로 반복할 때 1초당 30프레임.

### 프레임 레이트

- 단위시간(일반적으로 1초)에 해당하는 프레임 수.
- 게임 도중에 변경할 수 있음.
- ex) 간단한 타이틀 화면 : 60fps, 실제 게임 화면 : 30fps. 로 설정하는 시간 분배 설정이 가능.
  - 시간 배분하기 위해서는 프레임 레이트 변경을 고려해 프로그램을 계획.
  - 장면 종류를 따지지 않고 30fps로 일괄적으로 진행하는 게임도 적지 않음.

30fps를 선택하는 게임을 의외로 많이 볼 수 있음. 30fps로도 충분히 게임을 실행할 수 있다고 판단하는 사람들이 많기 때문.

30fps : 수직 동기를 2회에 한 번 기다리는 구조.

20fps : 수직 동기를 3회에 한 번 기다리는 구조.

20fps가 되면 움직임이 매우 둔해지므로 실제로 적용하는 경우는 매우 드뭄.

60fps가 요구되는 게임 장르 : 격투 게임. 상대의 움직임을 확인하면서 동작이 요구되기 때문.



# GPU

**GPU(Graphics Processing Unit : 그래픽 처리 장치)** : '그림으로 나타내는' 처리 함.

[그림 추가 69p]



GPU는 CPU로부터 '그림을 표시하라'는 명령을 받아 그림을 그리기 시작함.

메모리를 참조하며 그림 그리기를 진행하는데 프로그램을 참조하는 것이 아니라, 어떻게 그림을 그려야하는지가 기록되어 있는 설계도를 참조.

[그림 추가 70p-1]



**그리기 명령(drawing command)** : 어떻게 그림을 그려야하는지가 기록되어 있는 설계도.

그리기 명령은 CPU에 의해 메모리로 전송.

[그림 추가 70p-2]



그림을 그리는 장소 : 메모리의 임의 장소에 그림을 그리기 위한 공간을 확보해 그림.

CPU는 '어디 어디의 메모리 내용을 디스플레이어 표시하라'라는 지시를 보내 실제로 디스플레이어에 표시.

**프레임 버퍼(frame buffer)** : GPU가 그림을 그리는 공간.

[그림 추가 71p-1]



GPU는 CPU가 처리하는 작업과 병렬로 처리를 수행할 수 있음.

ex) CPU가 플레이어를 움직이게 하는 게임 처리를 하고 있는 동안 GPU는 내부에서 그림을 그릴 수 있음.

[그림추가 71p-2]



GPU는 프레임마다 그리기 명령을 참조.

60fps : 1초에 60장 그림 처리.

30fps : 1초에 30장 그림 처리.



# 더블 버퍼

그림을 그리는 공간인 프레임 버퍼는 1장으로 충분할까요?



1장만 있을 경우.

CPU에서 '이 프레임 버퍼를 디스플레이어 표시하라'는 명령을 전송하면 지정된 프레임 버퍼가 디스플레이에 표시.

표시 처리가 진행되고 있는 도중 GPU가 프레임 버퍼를 변경하게 되면 다른 그림이 화면 아래에 반 정도 남아 있을 가능성이 있음.

디스플레이는 수직동기 1회의 시간 동안 화면 왼쪽 위에서 오른쪽 아래를 향해 표시.

한 개의 프레임은 수직동기 1회의 시간 내 처리를 진행함.

[그림 72p]



표시처리 도중에 프레임 버퍼가 바뀌면 수직동기 중이더라도 화면의 표시내용이 바뀌게 됨.

ex) 'A'라는 문자를 화면에 표시하고 있는 도중에 프레임 버퍼 'B'라는 문자로 바뀌면 화면 아래쪽에는 'B' 아랫부분의 표시가 남음.

[그림 73p-1]



1장의 프레임 버퍼로는 무리가 있으므로 일반적으로는 2장을 준비해 처리를 진행함.

**더블 버퍼(double buffer)** 혹은 **이중 버퍼** : 2장의 프레임 버퍼를 준비하는 것.

미리 메모리상에 프레임 버퍼를 2장을 준비해두고 각각을 프레임 버퍼1, 프레임 버퍼2로 설정.

[그림 73p-2]



표시 처리의 기본적인 과정은 다음 단계를 반복하는 것.

1. 프레임 버퍼 1을 디스플레이에 표시하고 있는 동안에 GPU가 프레임 버퍼2에 그림을 표시.
2. 수직동기를 기다린다.
3. 프레임 버퍼2를 디스플레이에 표시하고 있는 동안 GPU가 프레임 버퍼 1에 그림을 표시한다.

[그림 74p-1]



수직동기가 일어나는 시간 내에 표시할 프레임 버퍼를 바꾸는 것이 포인트.

수직동기가 시작되면 잠시 동안 화면 바깥을 바꾸는 시간이 있기 때문에, 프레임 버퍼를 바꾸더라도 앞서 말한 바와 같이 화면 도중에 다른 그림이 표시되지 않음.

[그림 74p-2]



장점 : 표시 도중 화면이 오류나지 않고 제대로 된 화면으로 바꿀 수 있음.

단점 : 프레임 버퍼를 2장 준비하기 때문에 메모리가 소비.

하지만 이러한 방법이 일반적인 대책임.



# GPU에 관한 처리과정

GPU는 그림을 표현하기 위한 장치로 CPU와 병렬로 동작할 수 있다고 했음. 그러면 수직동기를 고려해 GPU에 관련된 처리를 어떻게 진행해야 할지에 대해 생각해보자.



## GPU의 처리과정

메인 루프의 시작부분은 수직동기가 끝난 직후기 때문에 가장 처음 해야 할 처리로 적합한 작업은 디스플레이에 표시되는 프레임 버퍼를 선택하는 것.

처리가 끝난 후에 제어기 정보의 처리를 진행하는 것이 좋음.

[그림 75p]



GPU로 그림을 표현하는 것은 현재 상태에선 조금 무리임.

게임의 정보가 이 시점에서는 명확하지 않은 경우가 대부분임.

- 카메라가 어느 곳을 비추고 있는지.
- 플레이어가 어디에 있고 어떠한 자세를 취하고 있는지.
- 적이 몇 개 있는지 등.

-> 그렇기 때문에 제어기의 정보를 받은 후에 게임 처리를 실행.

[그림 76p-1]



게임 처리를 대략적으로 끝내고, 그 결과를 GPU에서 그림으로 표현하기 위해 그리기 명령을 메모리에 넣음.

그리기 명령은 게임 정보(ex. 플레이어의 자세 등)를 참조해 작성.

그리기 명령 저장이 끝나면 수직동기를 기다리고 1프레임에 해당하는 메인 루프 처리를 종료함.

[그림 76p-1]



## CPU와 GPU의 처리과정

**랜더링(rendering)** : 그리기 명령을 참조해 실제로 그림으로 표현하도록 하는 것.

그리기 명령을 저장하고 바로 랜더링하는 과정.

[그림 77p-1]



위의 그림에서는 첫 프레임에서 'A'라는 문자를 표시하기 위한 그리기 명령을 저장하고 바로 랜더링함. 

GPU는 곧바로 프레임 버퍼에 'A'를 그려 넣고 그 후에 수직동기에서 표시하도록 함.

디스플레이에서는 신속히 다음 프레임에서 'A'라고 표시하므로 사용자에게는 매우 빠르다는 인상을 줄 수 있을 것임.

다만, 디스플레이에 깔끔하게 표시하기 위해서는 프레임 버퍼에 그려 넣는 작업이 제대로 끝나는 것을 기다려야 함. 그렇지 않으면 의도하지 않은 그림이 표시도리 가능성이 높음.



그리기 처리 자체에 시간이 걸리는 경우.

[그림 77p-2]



그리기 명령을 저장하면 동시에 랜더링을 실행하기 때문에 GPU의 그리기 처리가 프레임 도중에 시작되어 그리기 처리가 종료하기도 전에 수직동기의 순간이 되어 결과적으로 처리 오류가 됨.

플레이어를 움직이는 등의 게임 처리가 단시간으로 끝나면 처리 오류의 가능성은 낮아지지만 그렇다고 하더라도 그리기 처리에 의해 처리 오류가 발생할 가능성은 존재하게 됨.

GPU 프레임 시작 부분이 비어 있어 시간이 낭비되고 있는 것을 알 수 있음. 

'프레임 시작 부분부터 그리기 처리를 실행하면 효과적이지 않을까?' -> GPU는 CPU와 병렬로 처리할 수 있음.

시작 프레임에서는 그리기 명령을 저장하고, 다음 프레임의 시작 부분에서는 앞 프레임의 그리기 명령을 랜더링함.

[그림 78p]



처리과정

1. 처음 프레임에서는 그리기 명령을 저장하는 것만 실행한다.
2. 다음 프레임에서 그린다.
3. 그 다음 프레임에서 표시한다.

프레임의 시작 시점 부터 GPU가 처리할 수 있게 됨. 시간을 효율적으로 사용할 수 있고 처리 오류의 가능성도 낮출수 있게 됨.

문제 :  랜더링을 바로 실행하는 것보다 표시 타이밍이 1프레임 늦어짐.

-> 1프레임이라는 것은 60fps이기 때문에 체감하기에 매우 짧은 시간임. 1프레임 지연이 게임 플레이에 지장을 주지는 않기 때문에 일반적으로 이 방법이 도입되고 있음.



