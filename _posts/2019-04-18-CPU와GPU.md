---
layout: post
title:  CPU와 GPU
category: 게임을 움직이는 기술과 발상
description: 게임 프로그램과 그래픽 데이터는 스스로 움직일 순 없다. 바로 CPU와 GPU가 지시를 내려줘야 한다. CPU와 GPU가 어떻게 작동하는지에 대해 알아본다.
---

>  게임 프로그램과 그래픽 데이터는 스스로 움직일 순 없다. 바로 CPU와 GPU가 지시를 내려줘야 한다. CPU와 GPU가 어떻게 작동하는지에 대해 알아본다.



# CPU란

메모리 : 게임에 관련된 데이터를 배치하는 장소.

CPU : 그 데이터를 어떻게 다룰 것인지를 담당. -> 제어기 등 다른 기기를 제어하는 일을 담당하는 등 게임기의 핵심 역할을 함.

게임기는 CPU를 중심으로 동작하는데, CPU는 인간의 뇌와 같은 동작을 담당한다고 볼 수 있다.



# 프로그램과 CPU

CPU를 흔히 뇌와 비교하지만 스스로 동작하지는 않음. 동작하기 위해서는 지시를 받아야 함.

그 지시를 담당하는 것이 바로 프로그램.

프로그램은 게임이 실행될 때 메모리에 배치. CPU는 메모리상의 프로그램 위치를 확인하고 프로그램의 내용을 참조하면서 프로그램의 지시에 따라 동작.

이후 CPU는 프로그램의 내용을 지속적으로 참조하며, 기본적으로 게임이  종료될 때까지 동작함.



# 메모리상의 프로그램

**루프** : 게임에 관련된 처리를 순서대로 불러와 처리가 종료되면 처음부터 다시 처리하는 것을 반복 하는 것.

**메인루프** : 메인이 되는 처리.

메인 루프를 중심으로 각각의 처리를 불러오는 것이 게임의 기본적인 구조가 됨.

ex) 메인 루프에서 '플레이어 관련 처리'를 불러와 그 처리에서 '플레이어의 이동', '플레이어의 공격'이라는 처리를 불러냄.

![그림1](https://user-images.githubusercontent.com/26755686/56466249-15f13e80-644a-11e9-88bf-213573dcebb5.png)



적의 경우에는 플레이어와는 달리 여럿이기 때문에 '적에 관한 처리'를 불러낸 후 스테이지 존재하는 적의 수만큼 반복해 처리.

![그림2](https://user-images.githubusercontent.com/26755686/56466292-b5163600-644a-11e9-9946-c25a7754499f.png)



루프에서 처리를 불러오는 것이 기본이지만, 다음 그림과 같이 직접적인 구조로 구성할 수 있음.

![그림3](https://user-images.githubusercontent.com/26755686/56466345-6fa63880-644b-11e9-89dd-55eab696314e.png)



여러 명에서 프로그램을 개발하는 경우 : 불러오기 처리 장소를 개별적으로 만든 뒤 불러오는 것이 더욱 간단.

혼자서 프로그램을 제작하는 경우하는 경우라도 불러오는 처리 장소를 세세히 만들어두면 다른 부분에서도 유용하게 사용할 수 있어 편리할 것임. 메모리의 사용량도 낮출 수 있고, 오류가 생겼을 때도 문제점을 파악하기 쉬워짐.

개별 처리를 불러오는 형태로 구성하는 것이 전체적으로 효율이 높음.

ex) 플레이어와 적은 지면을 따라 이동하고 대면한 경우에는 서로 상대를 향해 공격할 것임. 공격할 때 그 공격이 상대에게 닿았는지 아닌지를 판단해야 함. 이러한 판단을 **충돌 확인**(또는 **충돌 판정**)이라고 함. 충돌 확인 처리를 플레이어용, 적 전용으로 개별적으로 만들 필요가 없음. 한 개만 만든 다음 플레이어 처리와 적 처리 양쪽 모두 불러오면 되기 때문.

![그림4](https://user-images.githubusercontent.com/26755686/56466419-fdceee80-644c-11e9-98f0-43c47bad5993.png)



# 오버레이

메모리는 한정된 자원이기 때문에, 프로그램을 만들 때 메모리가 부족하면 그래픽 데이터뿐만 아니라 프로그램 자체도 삭제 대상이 됨. 이번에 소개할 내용은 오버레이 방법으로 프로그램을 삭제 처리이다.

게임에는 타이틀 화면과 엔딩 화면이 있음. 우선 게임에서 두 화면이 동시에 실행되는 상황은 없을 것임. 그렇다고 이 두가지 화면의 프로그램으 메모리에 배치하는 것은 낭비라고 볼 수 있음.

![그림5](https://user-images.githubusercontent.com/26755686/56466541-93b74900-644e-11e9-99fa-e78392d8fbc4.png)

타이틀 화면이 표시돼야 될 때는 타이틀 화면 처리를 실행하는 프로그램을 디스크에 불러와 메모리에 배치함. 게임이 진행되고 엔딩이 표시돼야 될 떄는 타이틀 화면 프로그램이 들어 있던 공간에 엔딩 처리를 실행하는 프로그램을 덮어씌움.



타이틀 화면과 엔딩 화면 모두 이러한 처리 덕분에 사용되는 메모리 영역을 조금이라도 비울 수 있음.

![그림6](https://user-images.githubusercontent.com/26755686/56466676-bc8c0e00-644f-11e9-885f-60768f42d134.png)

주의 할 점 

- 그래픽 데이터 등에 비해 프로그램 크기가 작아서 많은 양의 메모리가 절약되는 것은 아니다.
- 오버레이를 실행하면 디버깅을 하기 어려워지거나 오류의 원인도 되기도 하다.

![그림7](https://user-images.githubusercontent.com/26755686/56466731-771c1080-6450-11e9-9a55-93da2ee7016e.png)

> 필요한 프로그램이 메모리 내 존재하지 않는 상황에 빠지는 경우.

오버레이는 특별한 경우를 제외하고는 잘 사용하지 않음.



# 메인 루프의 시작과 끝

메인 루프에서 가장 먼저 하고 싶은 처리 : 제어기로부터 들어온 입력을 확인하는데, 이는 입력 정보에 따라 처리 순서가 크게 달라질 가능성이 높다.

- 제어기 처리를 메인 루프의 도중에 진행

  ![그림8](https://user-images.githubusercontent.com/26755686/56466813-b72fc300-6451-11e9-8857-2bfce16baa78.png)

- 제어기 처리를 메인 루프의 초반에 진행

  ![그림9](https://user-images.githubusercontent.com/26755686/56466843-1beb1d80-6452-11e9-84f8-6e11e110a720.png)

이후의 플레이어나 적의 처리에 걸리는 시간은 상황에 따라 달라질 것임.

ex) 적이 10개 존재할 경우 1개일 때보다 처리시간이 다소 증가한다는 것은 쉽게 예상 가능.

따라서 제어기 처리 시점에 따라 처리 과정의 순서가 달라진다는 것을 알 수 있음.

![그림10](https://user-images.githubusercontent.com/26755686/56466941-8b154180-6453-11e9-8419-4fcc7782e5d9.png)

제어기 정보를 받는 타이밍이 다르면 사용자의 조작감이 떨어져 재미있는 게임이 될 수 없고, 화면상의 플레이어나 적의 이동량도 매번 달라질 뿐만 아니라 시간을 표시하는 카운트다운도 규칙적이지 않게 될 것임.

ex) 플레이어 처리에서 플레이어가 오른쪽으로 50 움직였다고 생각. 매번 같은 움직임을 한다면 동일한 속도로 오른쪽으로 움직일 것이라고 예상하겠지만, 실제로 그림과 같이 처리.

![그림11](https://user-images.githubusercontent.com/26755686/56467084-07f4eb00-6455-11e9-90c1-49ae5b2790b0.png)

플레이어의 위치를 불러오는 타이밍은 일정치가 않음. 그렇기 때문에 같은 속도로 움직이려고 의도하더라도 화면에 표시되는 플레이어는 각기 다른 움직임으로 이동.

이러한 문제는 메인 루프의 마지막에 '일정시간 대기'에 따라 해결 할 수 있다. 1/60초 주기로 특정 신호를 발생시켜 신호를 기다리는 것임.

'일정시간 대기'라는 것은 정확히 '특정 신호 대기'라고 볼 수 있음.

 ![그림12](https://user-images.githubusercontent.com/26755686/56467186-a0d83600-6456-11e9-859a-e416b0706867.png)

이러한 처리를 통해 대기시간은 발생되지만, 제어기 입력을 일정한 간격으로 할 수 있을 뿐만 아니라 플레이어도 같은 속도로 움직이게 할 수 있음.



# 수직동기와 프레임

**수직동기** : '특정 신호 대기'에서 말하는 신호. 기본적으로 1/60초의 주기로 디스플레이에서 발생.

디스플레이어에 어떤 영상이 표시될 때는 화면 위쪽부터 서서히 표시가 바뀜. 이렇게 바뀌는 라인의 화면 가장 아래에 도다하는 타이밍이 수직동기의 시작점이 됨. 바로 이 시점이 메인 루프의 시작으로 가장 좋은 타이밍이라고 할 수 있음.

![그림13](https://user-images.githubusercontent.com/26755686/56467608-1266b300-645c-11e9-8e6d-9e8d387e8ca9.png)

1은 수직 동기가 시작되는 시점임. '1/60초'란 일단 3에 도달하고 다시 1에 도달하기까지의 시간.

이러한 1의 순간에는 디스플레이 화면 가장 아래가 바뀌고 있음. 화면 색이 전부 바뀌면 다시 바뀌는 위치를 가장 위쪽으로 옮기지만, 실제로는 화면 가장 아래의 조금 더 아랫부분까지 바꾸러고 함. 위 그림의 2부분까지 화면을 바꾸는 처리를 지속함. 1에서 2의 구간을 **수직동기 구간**이라고 하며, 게임 화면을 선명하게 바꾸기 위한 상당히 중요한 과정임.

이와 같이 수직동기에 기초한 1/60초라는 시간을 기본단위로 게임 처리 루프를 반복하는데, 이러한 기본 단위를 **프레임**이라고 함. 

앞의 그림에서는 1프레임의 처리를 1/60초 이내에 전부 종료시키고 신호를 기다리고 있지만, 만일 처리가 1/60초를 넘으면 어떻게 될까요?

![그림14](https://user-images.githubusercontent.com/26755686/56467678-12b37e00-645d-11e9-857c-c500f70df02b.png)

프레임이 1/60초를 초과하면 다음 수직동기를 기다리게 됨. 그렇기 때문에 그 프레임에서만 1/30초를 소비하게 됨. 원래 1/60초를 의도하고 작업하던 처리에 두 배의 시간이 걸리게 됨. 이러한 지연이 연속되면 체감할 수 있을 정도로 게임이 느려짐.

![그림15](https://user-images.githubusercontent.com/26755686/56467865-5effbd80-645f-11e9-9b16-7a15befabf94.png)

게임 처리마다 플레이어가 10의 거리만큼 이동하는 예를 그림으로 나타내보면, 수직동기까지 게임 처리가 끝난 경우에는 최종적으로 40의 거리를 이동할 수 있음. 그러나 수직동기를 초과한 경우에는 총 이동량이 20에 그침. 플레이어가 소비하는 시간은 같지만 이동량은 반정도밖에 되지 않기 때문에 플레이어는 느린 게임이라고 느끼게 될 것임.

이와 같은 상태를 **처리지연** 혹은 **딜레이**이라고 함. 액션 게임이나 슈팅 게임 등에서 적이나 무기가 화면에 많이 나타날 경우 표시가 늦어지는 것처럼 느껴질 때가 있는데, 이것이 바로 처리 지연임. 처리지연이 지속되면 게임의 품질이 현저히 떨어지게 됨.